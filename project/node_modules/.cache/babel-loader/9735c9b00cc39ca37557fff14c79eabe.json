{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\r\n * Creates a new CLP.\r\n * If no argument is given, the CLP has no permissions for anyone.\r\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\r\n *   permission for only that user or role.\r\n * If the argument is any other JSON object, that object will be interpretted\r\n *   as a serialized CLP created with toJSON().\r\n *\r\n * <p>A CLP, or Class Level Permissions can be added to any\r\n * <code>Parse.Schema</code> to restrict access to only a subset of users\r\n * of your application.</p>\r\n *\r\n * <p>\r\n * For get/count/find/create/update/delete/addField using the following functions:\r\n *\r\n * Entity is type Parse.User or Parse.Role or string\r\n * Role is type Parse.Role or Name of Parse.Role\r\n *\r\n * getGetRequiresAuthentication()\r\n * setGetRequiresAuthentication(allowed: boolean)\r\n * getGetPointerFields()\r\n * setGetPointerFields(pointerFields: string[])\r\n * getGetAccess(entity: Entity)\r\n * setGetAccess(entity: Entity, allowed: boolean)\r\n * getPublicGetAccess()\r\n * setPublicGetAccess(allowed: boolean)\r\n * getRoleGetAccess(role: Role)\r\n * setRoleGetAccess(role: Role, allowed: boolean)\r\n * getFindRequiresAuthentication()\r\n * setFindRequiresAuthentication(allowed: boolean)\r\n * getFindPointerFields()\r\n * setFindPointerFields(pointerFields: string[])\r\n * getFindAccess(entity: Entity)\r\n * setFindAccess(entity: Entity, allowed: boolean)\r\n * getPublicFindAccess()\r\n * setPublicFindAccess(allowed: boolean)\r\n * getRoleFindAccess(role: Role)\r\n * setRoleFindAccess(role: Role, allowed: boolean)\r\n * getCountRequiresAuthentication()\r\n * setCountRequiresAuthentication(allowed: boolean)\r\n * getCountPointerFields()\r\n * setCountPointerFields(pointerFields: string[])\r\n * getCountAccess(entity: Entity)\r\n * setCountAccess(entity: Entity, allowed: boolean)\r\n * getPublicCountAccess()\r\n * setPublicCountAccess(allowed: boolean)\r\n * getRoleCountAccess(role: Role)\r\n * setRoleCountAccess(role: Role, allowed: boolean)\r\n * getCreateRequiresAuthentication()\r\n * setCreateRequiresAuthentication(allowed: boolean)\r\n * getCreatePointerFields()\r\n * setCreatePointerFields(pointerFields: string[])\r\n * getCreateAccess(entity: Entity)\r\n * setCreateAccess(entity: Entity, allowed: boolean)\r\n * getPublicCreateAccess()\r\n * setPublicCreateAccess(allowed: Boolean)\r\n * getRoleCreateAccess(role: Role)\r\n * setRoleCreateAccess(role: Role, allowed: boolean)\r\n * getUpdateRequiresAuthentication()\r\n * setUpdateRequiresAuthentication(allowed: boolean)\r\n * getUpdatePointerFields()\r\n * setUpdatePointerFields(pointerFields: string[])\r\n * getUpdateAccess(entity: Entity)\r\n * setUpdateAccess(entity: Entity, allowed: boolean)\r\n * getPublicUpdateAccess()\r\n * setPublicUpdateAccess(allowed: boolean)\r\n * getRoleUpdateAccess(role: Role)\r\n * setRoleUpdateAccess(role: Role, allowed: boolean)\r\n * getDeleteRequiresAuthentication()\r\n * setDeleteRequiresAuthentication(allowed: boolean)\r\n * getDeletePointerFields()\r\n * setDeletePointerFields(pointerFields: string[])\r\n * getDeleteAccess(entity: Entity)\r\n * setDeleteAccess(entity: Entity, allowed: boolean)\r\n * getPublicDeleteAccess()\r\n * setPublicDeleteAccess(allowed: boolean)\r\n * getRoleDeleteAccess(role: Role)\r\n * setRoleDeleteAccess(role: Role, allowed: boolean)\r\n * getAddFieldRequiresAuthentication()\r\n * setAddFieldRequiresAuthentication(allowed: boolean)\r\n * getAddFieldPointerFields()\r\n * setAddFieldPointerFields(pointerFields: string[])\r\n * getAddFieldAccess(entity: Entity)\r\n * setAddFieldAccess(entity: Entity, allowed: boolean)\r\n * getPublicAddFieldAccess()\r\n * setPublicAddFieldAccess(allowed: boolean)\r\n * getRoleAddFieldAccess(role: Role)\r\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\r\n * </p>\r\n *\r\n * @alias Parse.CLP\r\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\r\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\r\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\r\n   * Returns a JSON-encoded version of the CLP.\r\n   *\r\n   * @returns {object}\r\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function value()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\r\n     * Returns whether this CLP is equal to another object\r\n     *\r\n     * @param other The other object to compare to\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function value(other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function value(role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function value(entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function value(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function value(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function value(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function value(operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function value(operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\r\n     * Sets user pointer fields to allow permission for get/count/find operations.\r\n     *\r\n     * @param {string[]} pointerFields User pointer fields\r\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function value(pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\r\n     * @returns {string[]} User pointer fields\r\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function value()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\r\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\r\n     *\r\n     * @param {string[]} pointerFields User pointer fields\r\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function value(pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\r\n     * @returns {string[]} User pointer fields\r\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function value()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\r\n     * Sets whether the given user is allowed to retrieve fields from this class.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId.\r\n     * @param {string[]} fields fields to be protected\r\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function value(userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\r\n     * Returns array of fields are accessable to this user.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\r\n     * @returns {string[]}\r\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function value(userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\r\n     * Sets whether the given user is allowed to read from this class.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId.\r\n     * @param {boolean} allowed whether that user should have read access.\r\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function value(userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\r\n     * Get whether the given user id is *explicitly* allowed to read from this class.\r\n     * Even if this returns false, the user may still be able to access it if\r\n     * getPublicReadAccess returns true or a role that the user belongs to has\r\n     * write access.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function value(userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\r\n     * Sets whether the given user id is allowed to write to this class.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\r\n     * @param {boolean} allowed Whether that user should have write access.\r\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function value(userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\r\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\r\n     * Even if this returns false, the user may still be able to write it if\r\n     * getPublicWriteAccess returns true or a role that the user belongs to has\r\n     * write access.\r\n     *\r\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function value(userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\r\n     * Sets whether the public is allowed to read from this class.\r\n     *\r\n     * @param {boolean} allowed\r\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function value(allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\r\n     * Gets whether the public is allowed to read from this class.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function value()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\r\n     * Sets whether the public is allowed to write to this class.\r\n     *\r\n     * @param {boolean} allowed\r\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function value(allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\r\n     * Gets whether the public is allowed to write to this class.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function value()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\r\n     * Sets whether the public is allowed to protect fields in this class.\r\n     *\r\n     * @param {string[]} fields\r\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function value(fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\r\n     * Gets whether the public is allowed to read fields from this class.\r\n     *\r\n     * @returns {string[]}\r\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function value()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\r\n     * Gets whether users belonging to the given role are allowed\r\n     * to read from this class. Even if this returns false, the role may\r\n     * still be able to write it if a parent role has read access.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @returns {boolean} true if the role has read access. false otherwise.\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function value(role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\r\n     * Gets whether users belonging to the given role are allowed\r\n     * to write to this user. Even if this returns false, the role may\r\n     * still be able to write it if a parent role has write access.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @returns {boolean} true if the role has write access. false otherwise.\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function value(role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\r\n     * Sets whether users belonging to the given role are allowed\r\n     * to read from this class.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @param {boolean} allowed Whether the given role can read this object.\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function value(role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\r\n     * Sets whether users belonging to the given role are allowed\r\n     * to write to this class.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @param {boolean} allowed Whether the given role can write this object.\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function value(role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\r\n     * Gets whether users belonging to the given role are allowed\r\n     * to count to this user. Even if this returns false, the role may\r\n     * still be able to count it if a parent role has count access.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @returns {string[]}\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function value(role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\r\n     * Sets whether users belonging to the given role are allowed\r\n     * to set access field in this class.\r\n     *\r\n     * @param role The name of the role, or a Parse.Role object.\r\n     * @param {string[]} fields Fields to be protected by Role.\r\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\r\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function value(role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}