{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\n\nvar _setInterval2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-interval\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/toConsumableArray\"));\n\nvar _findIndex = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find-index\"));\n\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs3/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/asyncToGenerator\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n/**\n * https://github.com/francimedia/parse-js-local-storage\n *\n * @flow\n */\n\n\nvar QUEUE_KEY = 'Parse/Eventually/Queue';\nvar queueCache = [];\nvar dirtyCache = true;\nvar polling = undefined;\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\n\nvar EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save: function save(object\n  /*: ParseObject*/\n  )\n  /*: Promise*/\n  {\n    var serverOptions\n    /*: SaveOptions*/\n    = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('save', object, serverOptions);\n  },\n\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy: function destroy(object\n  /*: ParseObject*/\n  )\n  /*: Promise*/\n  {\n    var serverOptions\n    /*: RequestOptions*/\n    = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('destroy', object, serverOptions);\n  },\n\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId: function generateQueueId(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  )\n  /*: string*/\n  {\n    object._getId();\n\n    var className = object.className,\n        id = object.id,\n        _localId = object._localId;\n\n    var uniqueId = object.get('hash') || _localId;\n\n    return [action, className, id, uniqueId].join('_');\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  enqueue: function enqueue(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  , serverOptions\n  /*: SaveOptions | RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    var _this = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n      var queueData, queueId, index, prop;\n      return _regenerator.default.wrap(function (_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.getQueue();\n\n            case 2:\n              queueData = _context.sent;\n              queueId = _this.generateQueueId(action, object);\n              index = _this.queueItemExists(queueData, queueId);\n\n              if (index > -1) {\n                // Add cached values to new object if they don't exist\n                for (prop in queueData[index].object) {\n                  if (typeof object.get(prop) === 'undefined') {\n                    object.set(prop, queueData[index].object[prop]);\n                  }\n                }\n              } else {\n                index = queueData.length;\n              }\n\n              queueData[index] = {\n                queueId: queueId,\n                action: action,\n                object: object.toJSON(),\n                serverOptions: serverOptions,\n                id: object.id,\n                className: object.className,\n                hash: object.get('hash'),\n                createdAt: new Date()\n              };\n              return _context.abrupt(\"return\", _this.setQueue(queueData));\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  store: function store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, (0, _stringify.default)(data));\n  },\n  load: function load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<Array>}\n   * @static\n   */\n  getQueue: function getQueue()\n  /*: Promise<Array>*/\n  {\n    var _this2 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {\n      return _regenerator.default.wrap(function (_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!dirtyCache) {\n                _context2.next = 10;\n                break;\n              }\n\n              _context2.t0 = JSON;\n              _context2.next = 4;\n              return _this2.load();\n\n            case 4:\n              _context2.t1 = _context2.sent;\n\n              if (_context2.t1) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.t1 = '[]';\n\n            case 7:\n              _context2.t2 = _context2.t1;\n              queueCache = _context2.t0.parse.call(_context2.t0, _context2.t2);\n              dirtyCache = false;\n\n            case 10:\n              return _context2.abrupt(\"return\", queueCache);\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue: function setQueue(queue\n  /*: Queue*/\n  )\n  /*: Promise<void>*/\n  {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  remove: function remove(queueId\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    var _this3 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n      var queueData, index;\n      return _regenerator.default.wrap(function (_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _this3.getQueue();\n\n            case 2:\n              queueData = _context3.sent;\n              index = _this3.queueItemExists(queueData, queueId);\n\n              if (!(index > -1)) {\n                _context3.next = 8;\n                break;\n              }\n\n              (0, _splice.default)(queueData).call(queueData, index, 1);\n              _context3.next = 8;\n              return _this3.setQueue(queueData);\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear: function clear()\n  /*: Promise*/\n  {\n    queueCache = [];\n    return this.store([]);\n  },\n\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists: function queueItemExists(queue\n  /*: Queue*/\n  , queueId\n  /*: string*/\n  )\n  /*: number*/\n  {\n    return (0, _findIndex.default)(queue).call(queue, function (data) {\n      return data.queueId === queueId;\n    });\n  },\n\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {number}\n   * @static\n   */\n  length: function length()\n  /*: number*/\n  {\n    var _this4 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n      var queueData;\n      return _regenerator.default.wrap(function (_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _this4.getQueue();\n\n            case 2:\n              queueData = _context4.sent;\n              return _context4.abrupt(\"return\", queueData.length);\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  },\n\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  sendQueue: function sendQueue()\n  /*: Promise<boolean>*/\n  {\n    var _this5 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {\n      var queue, queueData, i, queueObject, id, hash, className, ObjectType;\n      return _regenerator.default.wrap(function (_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return _this5.getQueue();\n\n            case 2:\n              queue = _context5.sent;\n              queueData = (0, _toConsumableArray2.default)(queue);\n\n              if (!(queueData.length === 0)) {\n                _context5.next = 6;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", false);\n\n            case 6:\n              i = 0;\n\n            case 7:\n              if (!(i < queueData.length)) {\n                _context5.next = 26;\n                break;\n              }\n\n              queueObject = queueData[i];\n              id = queueObject.id, hash = queueObject.hash, className = queueObject.className;\n              ObjectType = _ParseObject.default.extend(className);\n\n              if (!id) {\n                _context5.next = 16;\n                break;\n              }\n\n              _context5.next = 14;\n              return _this5.process.byId(ObjectType, queueObject);\n\n            case 14:\n              _context5.next = 23;\n              break;\n\n            case 16:\n              if (!hash) {\n                _context5.next = 21;\n                break;\n              }\n\n              _context5.next = 19;\n              return _this5.process.byHash(ObjectType, queueObject);\n\n            case 19:\n              _context5.next = 23;\n              break;\n\n            case 21:\n              _context5.next = 23;\n              return _this5.process.create(ObjectType, queueObject);\n\n            case 23:\n              i += 1;\n              _context5.next = 7;\n              break;\n\n            case 26:\n              return _context5.abrupt(\"return\", true);\n\n            case 27:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }))();\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  sendQueueCallback: function sendQueueCallback(object\n  /*: ParseObject*/\n  , queueObject\n  /*: QueueObject*/\n  )\n  /*: Promise<void>*/\n  {\n    var _this6 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {\n      return _regenerator.default.wrap(function (_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (object) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", _this6.remove(queueObject.queueId));\n\n            case 2:\n              _context6.t0 = queueObject.action;\n              _context6.next = _context6.t0 === 'save' ? 5 : _context6.t0 === 'destroy' ? 20 : 33;\n              break;\n\n            case 5:\n              if (!(typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt))) {\n                _context6.next = 7;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", _this6.remove(queueObject.queueId));\n\n            case 7:\n              _context6.prev = 7;\n              _context6.next = 10;\n              return object.save(queueObject.object, queueObject.serverOptions);\n\n            case 10:\n              _context6.next = 12;\n              return _this6.remove(queueObject.queueId);\n\n            case 12:\n              _context6.next = 19;\n              break;\n\n            case 14:\n              _context6.prev = 14;\n              _context6.t1 = _context6[\"catch\"](7);\n\n              if (!(_context6.t1.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"')) {\n                _context6.next = 19;\n                break;\n              }\n\n              _context6.next = 19;\n              return _this6.remove(queueObject.queueId);\n\n            case 19:\n              return _context6.abrupt(\"break\", 33);\n\n            case 20:\n              _context6.prev = 20;\n              _context6.next = 23;\n              return object.destroy(queueObject.serverOptions);\n\n            case 23:\n              _context6.next = 25;\n              return _this6.remove(queueObject.queueId);\n\n            case 25:\n              _context6.next = 32;\n              break;\n\n            case 27:\n              _context6.prev = 27;\n              _context6.t2 = _context6[\"catch\"](20);\n\n              if (!(_context6.t2.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"')) {\n                _context6.next = 32;\n                break;\n              }\n\n              _context6.next = 32;\n              return _this6.remove(queueObject.queueId);\n\n            case 32:\n              return _context6.abrupt(\"break\", 33);\n\n            case 33:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6, null, [[7, 14], [20, 27]]);\n    }))();\n  },\n\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll: function poll() {\n    var _this7 = this;\n\n    var ms\n    /*: number*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;\n\n    if (polling) {\n      return;\n    }\n\n    polling = (0, _setInterval2.default)(function () {\n      var RESTController = _CoreManager.default.getRESTController();\n\n      RESTController.request('GET', 'health').then(function (_ref) {\n        var status = _ref.status;\n\n        if (status === 'ok') {\n          _this7.stopPoll();\n\n          return _this7.sendQueue();\n        }\n      }).catch(function (e) {\n        return e;\n      });\n    }, ms);\n  },\n\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll: function stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling: function isPolling()\n  /*: boolean*/\n  {\n    return !!polling;\n  },\n  _setPolling: function _setPolling(flag\n  /*: boolean*/\n  ) {\n    polling = flag;\n  },\n  process: {\n    create: function create(ObjectType, queueObject) {\n      var object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n    byId: function byId(ObjectType, queueObject) {\n      return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {\n        var sessionToken, query, results;\n        return _regenerator.default.wrap(function (_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                sessionToken = queueObject.serverOptions.sessionToken;\n                query = new _ParseQuery.default(ObjectType);\n                query.equalTo('objectId', queueObject.id);\n                _context7.next = 5;\n                return (0, _find.default)(query).call(query, {\n                  sessionToken: sessionToken\n                });\n\n              case 5:\n                results = _context7.sent;\n                return _context7.abrupt(\"return\", EventuallyQueue.sendQueueCallback(results[0], queueObject));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    },\n    byHash: function byHash(ObjectType, queueObject) {\n      return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {\n        var sessionToken, query, results;\n        return _regenerator.default.wrap(function (_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                sessionToken = queueObject.serverOptions.sessionToken;\n                query = new _ParseQuery.default(ObjectType);\n                query.equalTo('hash', queueObject.hash);\n                _context8.next = 5;\n                return (0, _find.default)(query).call(query, {\n                  sessionToken: sessionToken\n                });\n\n              case 5:\n                results = _context8.sent;\n\n                if (!(results.length > 0)) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", EventuallyQueue.sendQueueCallback(results[0], queueObject));\n\n              case 8:\n                return _context8.abrupt(\"return\", EventuallyQueue.process.create(ObjectType, queueObject));\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }))();\n    }\n  }\n};\nmodule.exports = EventuallyQueue;","map":null,"metadata":{},"sourceType":"script"}