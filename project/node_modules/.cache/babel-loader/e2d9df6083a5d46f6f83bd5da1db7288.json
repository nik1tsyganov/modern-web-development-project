{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\n/**\r\n * Copyright (c) 2015-present, Parse, LLC.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n */\n\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\r\n  required: boolean,\r\n  defaultValue: mixed,\r\n};*/\n\n/**\r\n * A Parse.Schema object is for handling schema data from Parse.\r\n * <p>All the schemas methods require MasterKey.\r\n *\r\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\r\n *\r\n * <pre>\r\n * const options = { required: true, defaultValue: 'hello world' };\r\n * const schema = new Parse.Schema('MyClass');\r\n * schema.addString('field', options);\r\n * schema.addIndex('index_name', { 'field': 1 });\r\n * schema.save();\r\n * </pre>\r\n * </p>\r\n *\r\n * @alias Parse.Schema\r\n */\n\nvar ParseSchema = /*#__PURE__*/function () {\n  /**\r\n   * @param {string} className Parse Class string.\r\n   */\n  function ParseSchema(className\n  /*: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\r\n   * Static method to get all schemas\r\n   *\r\n   * @returns {Promise} A promise that is resolved with the result when\r\n   * the query completes.\r\n   */\n\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n    value:\n    /**\r\n     * Get the Schema from Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\n    function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get(this.className).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n\n        return response;\n      });\n    }\n    /**\r\n     * Create a new Schema on Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      return controller.create(this.className, params);\n    }\n    /**\r\n     * Update a Schema on Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params);\n    }\n    /**\r\n     * Removing a Schema from Parse\r\n     * Can only be used on Schema without objects\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.delete(this.className);\n    }\n    /**\r\n     * Removes all objects from a Schema (class) in Parse.\r\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\n\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.purge(this.className);\n    }\n    /**\r\n     * Assert if ClassName has been filled\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\r\n     * Sets Class Level Permissions when creating / updating a Schema.\r\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\r\n     *\r\n     * @param {object | Parse.CLP} clp Class Level Permissions\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"setCLP\",\n    value: function (clp\n    /*: PermissionsMap | ParseCLP*/\n    ) {\n      if (clp instanceof _ParseCLP.default) {\n        this._clp = clp.toJSON();\n      } else {\n        this._clp = clp;\n      }\n\n      return this;\n    }\n    /**\r\n     * Adding a Field to Create / Update a Schema\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\r\n     * @param {object} options\r\n     * Valid options are:<ul>\r\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\r\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\r\n     *   <li>targetClass: Required if type is Pointer or Parse.Relation\r\n     * </ul>\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/\n    , type\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      type = type || 'String';\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n\n      if (type === 'Pointer') {\n        return this.addPointer(name, options.targetClass, options);\n      }\n\n      if (type === 'Relation') {\n        return this.addRelation(name, options.targetClass, options);\n      }\n\n      var fieldOptions = {\n        type: type\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\r\n     * Adding an Index to Create / Update a Schema\r\n     *\r\n     * @param {string} name Name of the index\r\n     * @param {object} index { field: value }\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     *\r\n     * <pre>\r\n     * schema.addIndex('index_name', { 'field': 1 });\r\n     * </pre>\r\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/\n    , index\n    /*: any*/\n    ) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\r\n     * Adding String Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'String', options);\n    }\n    /**\r\n     * Adding Number Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Number', options);\n    }\n    /**\r\n     * Adding Boolean Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Boolean', options);\n    }\n    /**\r\n     * Adding Date Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      if (options && options.defaultValue) {\n        options.defaultValue = {\n          __type: 'Date',\n          iso: new Date(options.defaultValue)\n        };\n      }\n\n      return this.addField(name, 'Date', options);\n    }\n    /**\r\n     * Adding File Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'File', options);\n    }\n    /**\r\n     * Adding GeoPoint Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'GeoPoint', options);\n    }\n    /**\r\n     * Adding Polygon Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Polygon', options);\n    }\n    /**\r\n     * Adding Array Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Array', options);\n    }\n    /**\r\n     * Adding Object Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Object', options);\n    }\n    /**\r\n     * Adding Pointer Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} targetClass Name of the target Pointer Class\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n\n      var fieldOptions = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n\n        if (options.defaultValue instanceof _ParseObject.default) {\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\n        }\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\r\n     * Adding Relation Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} targetClass Name of the target Pointer Class\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\r\n     * Deleting a Field to Update on a Schema\r\n     *\r\n     * @param {string} name Name of the field\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n    /**\r\n     * Deleting an Index to Update on a Schema\r\n     *\r\n     * @param {string} name Name of the field\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\n\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n  }], [{\n    key: \"all\",\n    value: function () {\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get('').then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\n\nvar DefaultController = {\n  send: function (className\n  /*: string*/\n  , method\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var params\n    /*: any*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\n      useMasterKey: true\n    });\n  },\n  get: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n  create: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n  update: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n  delete: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n  purge: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_indexOf","_classCallCheck2","_createClass2","_defineProperty2","_CoreManager","_ParseObject","_ParseCLP","FIELD_TYPES","ParseSchema","className","get","_fields","_indexes","key","assertClassName","controller","getSchemaController","then","response","Error","params","fields","indexes","classLevelPermissions","_clp","create","update","delete","purge","clp","toJSON","name","type","options","arguments","length","undefined","call","concat","addPointer","targetClass","addRelation","fieldOptions","required","defaultValue","index","addField","__type","iso","Date","toPointer","__op","results","DefaultController","send","method","RESTController","getRESTController","request","useMasterKey","setSchemaController","_default"],"sources":["C:/Users/brosk/Documents/Web Dev/modern-web-development-project/project/node_modules/parse/lib/browser/ParseSchema.js"],"sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\r\n\r\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\r\n\r\n_Object$defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nexports.default = void 0;\r\n\r\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\r\n\r\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\r\n\r\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\r\n\r\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\r\n\r\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\r\n/**\r\n * Copyright (c) 2015-present, Parse, LLC.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n */\r\n\r\n\r\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\r\n/*:: type FieldOptions = {\r\n  required: boolean,\r\n  defaultValue: mixed,\r\n};*/\r\n\r\n/**\r\n * A Parse.Schema object is for handling schema data from Parse.\r\n * <p>All the schemas methods require MasterKey.\r\n *\r\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\r\n *\r\n * <pre>\r\n * const options = { required: true, defaultValue: 'hello world' };\r\n * const schema = new Parse.Schema('MyClass');\r\n * schema.addString('field', options);\r\n * schema.addIndex('index_name', { 'field': 1 });\r\n * schema.save();\r\n * </pre>\r\n * </p>\r\n *\r\n * @alias Parse.Schema\r\n */\r\n\r\nvar ParseSchema = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {string} className Parse Class string.\r\n   */\r\n  function ParseSchema(className\r\n  /*: string*/\r\n  ) {\r\n    (0, _classCallCheck2.default)(this, ParseSchema);\r\n    (0, _defineProperty2.default)(this, \"className\", void 0);\r\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\r\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\r\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\r\n\r\n    if (typeof className === 'string') {\r\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\r\n        this.className = '_User';\r\n      } else {\r\n        this.className = className;\r\n      }\r\n    }\r\n\r\n    this._fields = {};\r\n    this._indexes = {};\r\n  }\r\n  /**\r\n   * Static method to get all schemas\r\n   *\r\n   * @returns {Promise} A promise that is resolved with the result when\r\n   * the query completes.\r\n   */\r\n\r\n\r\n  (0, _createClass2.default)(ParseSchema, [{\r\n    key: \"get\",\r\n    value:\r\n    /**\r\n     * Get the Schema from Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\r\n    function () {\r\n      this.assertClassName();\r\n\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      return controller.get(this.className).then(function (response) {\r\n        if (!response) {\r\n          throw new Error('Schema not found.');\r\n        }\r\n\r\n        return response;\r\n      });\r\n    }\r\n    /**\r\n     * Create a new Schema on Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\r\n\r\n  }, {\r\n    key: \"save\",\r\n    value: function () {\r\n      this.assertClassName();\r\n\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      var params = {\r\n        className: this.className,\r\n        fields: this._fields,\r\n        indexes: this._indexes,\r\n        classLevelPermissions: this._clp\r\n      };\r\n      return controller.create(this.className, params);\r\n    }\r\n    /**\r\n     * Update a Schema on Parse\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\r\n\r\n  }, {\r\n    key: \"update\",\r\n    value: function () {\r\n      this.assertClassName();\r\n\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      var params = {\r\n        className: this.className,\r\n        fields: this._fields,\r\n        indexes: this._indexes,\r\n        classLevelPermissions: this._clp\r\n      };\r\n      this._fields = {};\r\n      this._indexes = {};\r\n      return controller.update(this.className, params);\r\n    }\r\n    /**\r\n     * Removing a Schema from Parse\r\n     * Can only be used on Schema without objects\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\r\n\r\n  }, {\r\n    key: \"delete\",\r\n    value: function () {\r\n      this.assertClassName();\r\n\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      return controller.delete(this.className);\r\n    }\r\n    /**\r\n     * Removes all objects from a Schema (class) in Parse.\r\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\r\n     *\r\n     * @returns {Promise} A promise that is resolved with the result when\r\n     * the query completes.\r\n     */\r\n\r\n  }, {\r\n    key: \"purge\",\r\n    value: function () {\r\n      this.assertClassName();\r\n\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      return controller.purge(this.className);\r\n    }\r\n    /**\r\n     * Assert if ClassName has been filled\r\n     *\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"assertClassName\",\r\n    value: function () {\r\n      if (!this.className) {\r\n        throw new Error('You must set a Class Name before making any request.');\r\n      }\r\n    }\r\n    /**\r\n     * Sets Class Level Permissions when creating / updating a Schema.\r\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\r\n     *\r\n     * @param {object | Parse.CLP} clp Class Level Permissions\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"setCLP\",\r\n    value: function (clp\r\n    /*: PermissionsMap | ParseCLP*/\r\n    ) {\r\n      if (clp instanceof _ParseCLP.default) {\r\n        this._clp = clp.toJSON();\r\n      } else {\r\n        this._clp = clp;\r\n      }\r\n\r\n      return this;\r\n    }\r\n    /**\r\n     * Adding a Field to Create / Update a Schema\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\r\n     * @param {object} options\r\n     * Valid options are:<ul>\r\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\r\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\r\n     *   <li>targetClass: Required if type is Pointer or Parse.Relation\r\n     * </ul>\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addField\",\r\n    value: function (name\r\n    /*: string*/\r\n    , type\r\n    /*: string*/\r\n    ) {\r\n      var options\r\n      /*: FieldOptions*/\r\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      type = type || 'String';\r\n\r\n      if (!name) {\r\n        throw new Error('field name may not be null.');\r\n      }\r\n\r\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\r\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\r\n      }\r\n\r\n      if (type === 'Pointer') {\r\n        return this.addPointer(name, options.targetClass, options);\r\n      }\r\n\r\n      if (type === 'Relation') {\r\n        return this.addRelation(name, options.targetClass, options);\r\n      }\r\n\r\n      var fieldOptions = {\r\n        type: type\r\n      };\r\n\r\n      if (typeof options.required === 'boolean') {\r\n        fieldOptions.required = options.required;\r\n      }\r\n\r\n      if (options.defaultValue !== undefined) {\r\n        fieldOptions.defaultValue = options.defaultValue;\r\n      }\r\n\r\n      this._fields[name] = fieldOptions;\r\n      return this;\r\n    }\r\n    /**\r\n     * Adding an Index to Create / Update a Schema\r\n     *\r\n     * @param {string} name Name of the index\r\n     * @param {object} index { field: value }\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     *\r\n     * <pre>\r\n     * schema.addIndex('index_name', { 'field': 1 });\r\n     * </pre>\r\n     */\r\n\r\n  }, {\r\n    key: \"addIndex\",\r\n    value: function (name\r\n    /*: string*/\r\n    , index\r\n    /*: any*/\r\n    ) {\r\n      if (!name) {\r\n        throw new Error('index name may not be null.');\r\n      }\r\n\r\n      if (!index) {\r\n        throw new Error('index may not be null.');\r\n      }\r\n\r\n      this._indexes[name] = index;\r\n      return this;\r\n    }\r\n    /**\r\n     * Adding String Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addString\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'String', options);\r\n    }\r\n    /**\r\n     * Adding Number Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addNumber\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'Number', options);\r\n    }\r\n    /**\r\n     * Adding Boolean Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addBoolean\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'Boolean', options);\r\n    }\r\n    /**\r\n     * Adding Date Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addDate\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      if (options && options.defaultValue) {\r\n        options.defaultValue = {\r\n          __type: 'Date',\r\n          iso: new Date(options.defaultValue)\r\n        };\r\n      }\r\n\r\n      return this.addField(name, 'Date', options);\r\n    }\r\n    /**\r\n     * Adding File Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addFile\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'File', options);\r\n    }\r\n    /**\r\n     * Adding GeoPoint Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addGeoPoint\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'GeoPoint', options);\r\n    }\r\n    /**\r\n     * Adding Polygon Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addPolygon\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'Polygon', options);\r\n    }\r\n    /**\r\n     * Adding Array Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addArray\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'Array', options);\r\n    }\r\n    /**\r\n     * Adding Object Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addObject\",\r\n    value: function (name\r\n    /*: string*/\r\n    , options\r\n    /*: FieldOptions*/\r\n    ) {\r\n      return this.addField(name, 'Object', options);\r\n    }\r\n    /**\r\n     * Adding Pointer Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} targetClass Name of the target Pointer Class\r\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addPointer\",\r\n    value: function (name\r\n    /*: string*/\r\n    , targetClass\r\n    /*: string*/\r\n    ) {\r\n      var options\r\n      /*: FieldOptions*/\r\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n\r\n      if (!name) {\r\n        throw new Error('field name may not be null.');\r\n      }\r\n\r\n      if (!targetClass) {\r\n        throw new Error('You need to set the targetClass of the Pointer.');\r\n      }\r\n\r\n      var fieldOptions = {\r\n        type: 'Pointer',\r\n        targetClass: targetClass\r\n      };\r\n\r\n      if (typeof options.required === 'boolean') {\r\n        fieldOptions.required = options.required;\r\n      }\r\n\r\n      if (options.defaultValue !== undefined) {\r\n        fieldOptions.defaultValue = options.defaultValue;\r\n\r\n        if (options.defaultValue instanceof _ParseObject.default) {\r\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\r\n        }\r\n      }\r\n\r\n      this._fields[name] = fieldOptions;\r\n      return this;\r\n    }\r\n    /**\r\n     * Adding Relation Field\r\n     *\r\n     * @param {string} name Name of the field that will be created on Parse\r\n     * @param {string} targetClass Name of the target Pointer Class\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"addRelation\",\r\n    value: function (name\r\n    /*: string*/\r\n    , targetClass\r\n    /*: string*/\r\n    ) {\r\n      if (!name) {\r\n        throw new Error('field name may not be null.');\r\n      }\r\n\r\n      if (!targetClass) {\r\n        throw new Error('You need to set the targetClass of the Relation.');\r\n      }\r\n\r\n      this._fields[name] = {\r\n        type: 'Relation',\r\n        targetClass: targetClass\r\n      };\r\n      return this;\r\n    }\r\n    /**\r\n     * Deleting a Field to Update on a Schema\r\n     *\r\n     * @param {string} name Name of the field\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"deleteField\",\r\n    value: function (name\r\n    /*: string*/\r\n    ) {\r\n      this._fields[name] = {\r\n        __op: 'Delete'\r\n      };\r\n      return this;\r\n    }\r\n    /**\r\n     * Deleting an Index to Update on a Schema\r\n     *\r\n     * @param {string} name Name of the field\r\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\r\n     */\r\n\r\n  }, {\r\n    key: \"deleteIndex\",\r\n    value: function (name\r\n    /*: string*/\r\n    ) {\r\n      this._indexes[name] = {\r\n        __op: 'Delete'\r\n      };\r\n      return this;\r\n    }\r\n  }], [{\r\n    key: \"all\",\r\n    value: function () {\r\n      var controller = _CoreManager.default.getSchemaController();\r\n\r\n      return controller.get('').then(function (response) {\r\n        if (response.results.length === 0) {\r\n          throw new Error('Schema not found.');\r\n        }\r\n\r\n        return response.results;\r\n      });\r\n    }\r\n  }]);\r\n  return ParseSchema;\r\n}();\r\n\r\nvar DefaultController = {\r\n  send: function (className\r\n  /*: string*/\r\n  , method\r\n  /*: string*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    var params\r\n    /*: any*/\r\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n\r\n    var RESTController = _CoreManager.default.getRESTController();\r\n\r\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\r\n      useMasterKey: true\r\n    });\r\n  },\r\n  get: function (className\r\n  /*: string*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    return this.send(className, 'GET');\r\n  },\r\n  create: function (className\r\n  /*: string*/\r\n  , params\r\n  /*: any*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    return this.send(className, 'POST', params);\r\n  },\r\n  update: function (className\r\n  /*: string*/\r\n  , params\r\n  /*: any*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    return this.send(className, 'PUT', params);\r\n  },\r\n  delete: function (className\r\n  /*: string*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    return this.send(className, 'DELETE');\r\n  },\r\n  purge: function (className\r\n  /*: string*/\r\n  )\r\n  /*: Promise*/\r\n  {\r\n    var RESTController = _CoreManager.default.getRESTController();\r\n\r\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\r\n      useMasterKey: true\r\n    });\r\n  }\r\n};\r\n\r\n_CoreManager.default.setSchemaController(DefaultController);\r\n\r\nvar _default = ParseSchema;\r\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}