{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\r\n * Copyright (c) 2015-present, Parse, LLC.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n */\n\n/**\r\n * Creates a new Polygon with any of the following forms:<br>\r\n *   <pre>\r\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\r\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\r\n *   </pre>\r\n *\r\n * <p>Represents a coordinates that may be associated\r\n * with a key in a ParseObject or used as a reference point for geo queries.\r\n * This allows proximity-based queries on the key.</p>\r\n *\r\n * <p>Example:<pre>\r\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\r\n *   var object = new Parse.Object(\"PlaceObject\");\r\n *   object.set(\"area\", polygon);\r\n *   object.save();</pre></p>\r\n *\r\n * @alias Parse.Polygon\r\n */\n\n\nvar ParsePolygon = /*#__PURE__*/function () {\n  /**\r\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\r\n   */\n  function ParsePolygon(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParsePolygon);\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\r\n   * Coordinates value for this Polygon.\r\n   * Throws an exception if not valid type.\r\n   *\r\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\r\n   * @returns {number[][]}\r\n   */\n\n\n  (0, _createClass2.default)(ParsePolygon, [{\n    key: \"coordinates\",\n    get: function get()\n    /*: Array<Array<number>>*/\n    {\n      return this._coordinates;\n    },\n    set: function set(coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    ) {\n      this._coordinates = ParsePolygon._validate(coords);\n    }\n    /**\r\n     * Returns a JSON representation of the Polygon, suitable for Parse.\r\n     *\r\n     * @returns {object}\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function value()\n    /*: { __type: string, coordinates: Array<Array<number>> }*/\n    {\n      ParsePolygon._validate(this._coordinates);\n\n      return {\n        __type: 'Polygon',\n        coordinates: this._coordinates\n      };\n    }\n    /**\r\n     * Checks if two polygons are equal\r\n     *\r\n     * @param {(Parse.Polygon | object)} other\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function value(other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n        return false;\n      }\n\n      var isEqual = true;\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n          isEqual = false;\n          break;\n        }\n      }\n\n      return isEqual;\n    }\n    /**\r\n     *\r\n     * @param {Parse.GeoPoint} point\r\n     * @returns {boolean} Returns if the point is contained in the polygon\r\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function value(point\n    /*: ParseGeoPoint*/\n    )\n    /*: boolean*/\n    {\n      var minX = this._coordinates[0][0];\n      var maxX = this._coordinates[0][0];\n      var minY = this._coordinates[0][1];\n      var maxY = this._coordinates[0][1];\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        var p = this._coordinates[i];\n        minX = Math.min(p[0], minX);\n        maxX = Math.max(p[0], maxX);\n        minY = Math.min(p[1], minY);\n        maxY = Math.max(p[1], maxY);\n      }\n\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n      if (outside) {\n        return false;\n      }\n\n      var inside = false;\n\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\n        var startX = this._coordinates[_i][0];\n        var startY = this._coordinates[_i][1];\n        var endX = this._coordinates[j][0];\n        var endY = this._coordinates[j][1];\n        var intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n\n      return inside;\n    }\n    /**\r\n     * Validates that the list of coordinates can form a valid polygon\r\n     *\r\n     * @param {Array} coords the list of coordinates to validate as a polygon\r\n     * @throws {TypeError}\r\n     * @returns {number[][]} Array of coordinates if validated.\r\n     */\n\n  }], [{\n    key: \"_validate\",\n    value: function value(coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    )\n    /*: Array<Array<number>>*/\n    {\n      if (!(0, _isArray.default)(coords)) {\n        throw new TypeError('Coordinates must be an Array');\n      }\n\n      if (coords.length < 3) {\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n      }\n\n      var points = [];\n\n      for (var i = 0; i < coords.length; i += 1) {\n        var coord = coords[i];\n        var geoPoint = void 0;\n\n        if (coord instanceof _ParseGeoPoint.default) {\n          geoPoint = coord;\n        } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n        } else {\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n        }\n\n        points.push([geoPoint.latitude, geoPoint.longitude]);\n      }\n\n      return points;\n    }\n  }]);\n  return ParsePolygon;\n}();\n\nvar _default = ParsePolygon;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}