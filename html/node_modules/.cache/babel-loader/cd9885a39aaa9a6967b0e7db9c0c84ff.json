{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function () {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function (entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function (operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function (operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function (fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","_Object$defineProperties","_Object$getOwnPropertyDescriptors","_forEachInstanceProperty","_Object$getOwnPropertyDescriptor","_filterInstanceProperty","_Object$getOwnPropertySymbols","_Object$keys2","_Array$isArray2","_getIteratorMethod","_Symbol","_Array$from","_sliceInstanceProperty2","exports","value","default","_isArray","_keys","_slice","_assign","_slicedToArray2","_entries","_every","_includes","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_map","_ParseRole","_ParseUser","ownKeys","object","enumerableOnly","keys","symbols","call","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","_context3","_context4","source","Object","key","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","return","minLen","_context2","_arrayLikeToArray","prototype","toString","constructor","name","test","arr","len","arr2","Array","PUBLIC_KEY","VALID_PERMISSIONS","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","userId","_this","permissionsMap","_iterator","_step","_loop","_step$value","operation","group","action","charAt","toUpperCase","concat","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","_iterator2","_step2","_step2$value","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","_permission","_context","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","pointer","user","other","permissions","otherPermissions","_permission2","otherUsers","getName","id","Error","permission","_parseEntity","returnBoolean","undefined","fields","field","_setGroupPointerPermission","_getGroupPointerPermissions","getReadAccess","getWriteAccess","setProtectedFields","getProtectedFields","_default"],"sources":["/Users/NikitaMac/Desktop/Modern Web Development/Homework/modern-web-development-project/project/node_modules/parse/lib/browser/ParseCLP.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function () {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function (entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function (operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function (operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function (fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}